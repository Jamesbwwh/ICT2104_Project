// *************************************************************************************************
// Timer service routines.
// *************************************************************************************************

// *************************************************************************************************
// Include section

// system
#include "project.h"

// driver
#include "timer.h"
#include "ports.h"
#include "buzzer.h"
#include "display.h"

// logic
#include "clock.h"
#include "alarm.h"

// *************************************************************************************************
// Prototypes section
void (*fptr_Timer0_A3_function)(void);

// *************************************************************************************************
// Global Variable section
struct timer sTimer;

// *************************************************************************************************
// Extern section
extern void to_lpm(void);

// *************************************************************************************************
// @fn          Timer0_Init
// @brief       Set Timer0 to a period of 1 or 2 sec. IRQ TACCR0 is asserted when timer overflows.
// @param       none
// @return      none
// *************************************************************************************************
void Timer0_Init(void) {
    // Set interrupt frequency to 1Hz
    TA0CCR0 = 32768 - 1;

    // Enable timer interrupt
    TA0CCTL0 |= CCIE;

    // Clear and start timer now
    // Continuous mode: Count to 0xFFFF and restart from 0 again - 1sec timing will be generated by
    // ISR
    TA0CTL |= TASSEL0 + MC1 + TACLR;
}

// *************************************************************************************************
// @fn          Timer0_Start
// @brief       Start Timer0.
// @param       none
// @return      none
// *************************************************************************************************
void Timer0_Start(void) {
    // Start Timer0 in continuous mode
    TA0CTL |= MC_2;
}

// *************************************************************************************************
// @fn          Timer0_Stop
// @brief       Stop and reset Timer0.
// @param       none
// @return      none
// *************************************************************************************************
void Timer0_Stop(void) {
    // Stop Timer0
    TA0CTL &= ~MC_2;

    // Set Timer0 count register to 0x0000
    TA0R = 0;
}

// *************************************************************************************************
// @fn          Timer0_A3_Start
// @brief       Trigger IRQ every "ticks" microseconds
// @param       ticks (1 tick = 1/32768 sec)
// @return      none
// *************************************************************************************************
void Timer0_A3_Start(u16 ticks) {
    u16 value = 0;

    // Store timer ticks in global variable
    sTimer.timer0_A3_ticks = ticks;

    // Delay based on current counter value
    // To make sure this value is correctly read
    while (value != TA0R)
        value = TA0R;
    value += ticks;

    // Update CCR
    TA0CCR3 = value;

    // Reset IRQ flag
    TA0CCTL3 &= ~CCIFG;

    // Enable timer interrupt
    TA0CCTL3 |= CCIE;
}

// *************************************************************************************************
// @fn          Timer0_A3_Stop
// @brief       Stop Timer0_A3.
// @param       none
// @return      none
// *************************************************************************************************
void Timer0_A3_Stop(void) {
    // Clear timer interrupt
    TA0CCTL3 &= ~CCIE;
}

// *************************************************************************************************
// @fn          Timer0_A4_Delay
// @brief       Wait for some microseconds
// @param       ticks (1 tick = 1/32768 sec)
// @return      none
// *************************************************************************************************
void Timer0_A4_Delay(u16 ticks) {
    u16 value = 0;

    // Exit immediately if Timer0 not running - otherwise we'll get stuck here
    if ((TA0CTL & (BIT4 | BIT5)) == 0)
        return;

    // Disable timer interrupt
    TA0CCTL4 &= ~CCIE;

    // Clear delay_over flag
    sys.flag.delay_over = 0;

    // Add delay to current timer value
    // To make sure this value is correctly read
    while (value != TA0R)
        value = TA0R;
    value += ticks;

    // Update CCR
    TA0CCR4 = value;

    // Reset IRQ flag
    TA0CCTL4 &= ~CCIFG;

    // Enable timer interrupt
    TA0CCTL4 |= CCIE;

    // Wait for timer IRQ
    while (1) {
        // Delay in LPM
        to_lpm();               // will also set GIE again

#ifdef USE_WATCHDOG
        // Service watchdog
        WDTCTL = WDTPW + WDTIS__512K + WDTSSEL__ACLK + WDTCNTCL;
#endif
        // Redraw stopwatch display
        //if (is_stopwatch())
        //    display_stopwatch(LINE2, DISPLAY_LINE_UPDATE_PARTIAL);

        // Check stop condition
        // disable interrupt to prevent flag's change caused by interrupt methods
        __disable_interrupt();
        if (sys.flag.delay_over)
            break;
    }
    __enable_interrupt();
}

// *************************************************************************************************
// @fn          TIMER0_A0_ISR
// @brief       IRQ handler for TIMER0_A0 IRQ
//                              Timer0_A0       1/1sec clock tick                       (serviced by
// function TIMER0_A0_ISR)
//                              Timer0_A1
//                                                               (serviced by function
// TIMER0_A1_5_ISR)
//                              Timer0_A2       1/100 sec Stopwatch                     (serviced by
// function TIMER0_A1_5_ISR)
//                              Timer0_A3       Configurable periodic IRQ       (serviced by
// function TIMER0_A1_5_ISR)
//                              Timer0_A4       One-time delay                          (serviced by
// function TIMER0_A1_5_ISR)
// @param       none
// @return      none
// *************************************************************************************************
#pragma vector = TIMER0_A0_VECTOR
__interrupt void TIMER0_A0_ISR(void) {
    static u8 button_lock_counter = 0;

    TA0CCTL0 &= ~CCIE;   // Disable IE
    TA0CCTL0 &= ~CCIFG;  // Reset IRQ flag
    TA0CCR0 += 32768;    // Add 1 sec to TACCR0 register (IRQ will be asserted at 0x7FFF and 0xFFFF = 1 sec intervals)
    TA0CCTL0 |= CCIE;    // Enable IE

    clock_tick();    // Add 1 second to global time
    display.flag.update_time = 1;    // Set clock update flag

    // Service modules that require 1/min processing
    if (sTime.drawFlag >= 2) {
        check_alarm();        // Check if alarm needs to be turned on
    }

    // Service active modules that require 1/s processing
    if (sAlarm.state == ALARM_ON) {
        // Decrement alarm duration counter
        if (sAlarm.duration-- > 0) {
            request.flag.buzzer = 1;
        } else {
            sAlarm.duration = ALARM_ON_DURATION;
            stop_alarm();
        }
    }

    if (sys.flag.idle_timeout_enabled) {
        if (sTime.system_time - sTime.last_activity > INACTIVITY_TIME)
            sys.flag.idle_timeout = 1;  //setFlag(sysFlag_g, SYS_TIMEOUT_IDLE);
    }

    // Turn the Backlight off after timeout
    if (sButton.backlight_status == 1) {
        if (sButton.backlight_timeout > BACKLIGHT_TIME_ON) {
            //turn off Backlight
            P2OUT &= ~BUTTON_BACKLIGHT_PIN;
            P2DIR &= ~BUTTON_BACKLIGHT_PIN;
            sButton.backlight_timeout = 0;
            sButton.backlight_status = 0;
        } else {
            sButton.backlight_timeout++;
        }
    }

    // -------------------------------------------------------------------
    // Detect continuous button high states

    // Trying to lock/unlock buttons?
    if (BUTTON_NUM_IS_PRESSED && BUTTON_DOWN_IS_PRESSED) {
        if (button_lock_counter++ > LEFT_BUTTON_LONG_TIME) {
            // Toggle lock / unlock buttons flag
            sys.flag.lock_buttons = ~sys.flag.lock_buttons;

            // Reset button lock counter
            button_lock_counter = 0;
        }
    } else {                    // Trying to create a long button press?
        // Reset button lock counter
        button_lock_counter = 0;

        if (BUTTON_STAR_IS_PRESSED) {
            sButton.star_timeout++;

            // Check if button was held low for some seconds
            if (sButton.star_timeout > LEFT_BUTTON_LONG_TIME) {
                button.flag.star_long = 1;
                button.flag.star_not_long = 0;
                sButton.star_timeout = 0;
                // Return interrupt edge to normal value
                BUTTONS_IES &= ~BUTTON_STAR_PIN;
            }
        } else {                // there was a button press not long enough
            sButton.star_timeout = 0;
        }

        if (BUTTON_NUM_IS_PRESSED) {
            sButton.num_timeout++;

            // Check if button was held low for some seconds
            if (sButton.num_timeout > LEFT_BUTTON_LONG_TIME) {
                button.flag.num_long = 1;
                button.flag.num_not_long = 0;
                sButton.num_timeout = 0;
                // Return interrupt edge to normal value
                BUTTONS_IES &= ~BUTTON_NUM_PIN;
            }
        } else {                // there was a button press not long enough
            sButton.num_timeout = 0;
        }
    }

    _BIC_SR_IRQ(LPM3_bits);    // Exit from LPM3 on RETI
}

// *************************************************************************************************
// @fn          Timer0_A1_5_ISR
// @brief       IRQ handler for timer IRQ.
//                              Timer0_A0       1/1sec clock tick (serviced by function
// TIMER0_A0_ISR)
//                              Timer0_A1       BlueRobin timer
//                              Timer0_A2       1/100 sec Stopwatch
//                              Timer0_A3       Configurable periodic IRQ (used by button_repeat and
// buzzer)
//                              Timer0_A4       One-time delay
// @param       none
// @return      none
// *************************************************************************************************
#pragma vector = TIMER0_A1_VECTOR
__interrupt void TIMER0_A1_5_ISR(void) {
    u16 value = 0;

    switch (TA0IV) {
    // Timer0_A3    Configurable periodic IRQ (used by button_repeat and buzzer)
    case 0x06:
        TA0CCTL3 &= ~CCIE;                  // Disable IE
        TA0CCTL3 &= ~CCIFG;                 // Reset IRQ flag
        while (value != TA0R) value = TA0R; // Store new value in CCR
        value += sTimer.timer0_A3_ticks;    // To make sure this value is correctly read
        TA0CCR3 = value;                    // Load CCR register with next capture point
        TA0CCTL3 |= CCIE;                   // Enable timer interrupt
        fptr_Timer0_A3_function();          // Call function handler
        break;

    // Timer0_A4    One-time delay
    case 0x08:
        TA0CCTL4 &= ~CCIE;             // Disable IE
        TA0CCTL4 &= ~CCIFG;            // Reset IRQ flag
        sys.flag.delay_over = 1;       // Set delay over flag
        break;
    }

    _BIC_SR_IRQ(LPM3_bits);    // Exit from LPM3 on RETI
}
